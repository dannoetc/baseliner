"""tenant-scoped unique constraints for device keys, policies, admin keys

Revision ID: 2c7b6c4f2ad1
Revises: 0f13df607edd
Create Date: 2025-12-30

"""

from __future__ import annotations

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = "2c7b6c4f2ad1"
down_revision = "0f13df607edd"
branch_labels = None
depends_on = None


def _find_unique_by_cols(table: str, cols: list[str]) -> tuple[str | None, str | None]:
    """Find a UNIQUE constraint or unique index by its column signature.

    Returns:
        ("constraint", name) if a named unique constraint matches
        ("index", name) if a unique index matches
        (None, None) if not found

    Note: SQLite frequently autogenerates constraint/index names, so column
    signature is the most reliable way to locate the existing uniqueness.
    """
    bind = op.get_bind()
    insp = sa.inspect(bind)

    # Unique constraints
    for uc in insp.get_unique_constraints(table):
        if uc.get("column_names") == cols and uc.get("name"):
            return ("constraint", uc["name"])

    # Unique indexes fallback
    for ix in insp.get_indexes(table):
        if ix.get("unique") and ix.get("column_names") == cols and ix.get("name"):
            return ("index", ix["name"])

    return (None, None)


def _swap_unique_constraint(
    table_name: str,
    old_name: str,
    new_name: str,
    old_columns: list[str],
    new_columns: list[str],
) -> None:
    """Replace a unique constraint with a new one.

    Why this exists:
    - On PostgreSQL we can drop/create constraints directly.
    - On SQLite, adding/dropping constraints requires table recreation (batch mode),
      and constraint/index names are often autogenerated. So we locate the *old*
      uniqueness by column signature rather than assumed names.

    Batch recreation on PostgreSQL can attempt to drop/recreate primary keys which
    breaks FKs, so we only use batch_alter_table when the SQLite dialect requires it.
    """
    bind = op.get_bind()
    dialect_name = bind.dialect.name

    insp = sa.inspect(bind)

    # Skip if the table doesn't exist (deployment environments may be mid-bootstrap).
    if not insp.has_table(table_name):
        return

    existing_uniques = {uc.get("name") for uc in insp.get_unique_constraints(table_name) if uc.get("name")}

    if dialect_name == "sqlite":
        old_kind, old_found = _find_unique_by_cols(table_name, old_columns)
        new_kind, new_found = _find_unique_by_cols(table_name, new_columns)

        # If we're already in the desired state (new exists, old absent), do nothing.
        if new_kind and not old_kind:
            return

        with op.batch_alter_table(table_name, recreate="always") as batch:
            # Drop the old uniqueness (by signature, not assumed name).
            if old_kind == "constraint" and old_found:
                batch.drop_constraint(old_found, type_="unique")
            elif old_kind == "index" and old_found:
                batch.drop_index(old_found)

            # Only create the new uniqueness if it doesn't already exist.
            if not new_kind:
                batch.create_unique_constraint(new_name, new_columns)

        return

    # Non-SQLite: use explicit constraint operations (names are stable).
    if old_name in existing_uniques:
        op.drop_constraint(old_name, table_name=table_name, type_="unique")

    # If the new one already exists, avoid re-adding it.
    existing_uniques = {uc.get("name") for uc in insp.get_unique_constraints(table_name) if uc.get("name")}
    if new_name not in existing_uniques:
        op.create_unique_constraint(new_name, table_name=table_name, columns=new_columns)


def upgrade() -> None:
    _swap_unique_constraint(
        table_name="devices",
        old_name="devices_device_key_key",
        new_name="uq_devices_tenant_id_device_key",
        old_columns=["device_key"],
        new_columns=["tenant_id", "device_key"],
    )
    _swap_unique_constraint(
        table_name="policies",
        old_name="policies_name_key",
        new_name="uq_policies_tenant_id_name",
        old_columns=["name"],
        new_columns=["tenant_id", "name"],
    )
    _swap_unique_constraint(
        table_name="admin_keys",
        old_name="admin_keys_key_hash_key",
        new_name="uq_admin_keys_tenant_id_key_hash",
        old_columns=["key_hash"],
        new_columns=["tenant_id", "key_hash"],
    )


def downgrade() -> None:
    _swap_unique_constraint(
        table_name="admin_keys",
        old_name="uq_admin_keys_tenant_id_key_hash",
        new_name="admin_keys_key_hash_key",
        old_columns=["tenant_id", "key_hash"],
        new_columns=["key_hash"],
    )
    _swap_unique_constraint(
        table_name="policies",
        old_name="uq_policies_tenant_id_name",
        new_name="policies_name_key",
        old_columns=["tenant_id", "name"],
        new_columns=["name"],
    )
    _swap_unique_constraint(
        table_name="devices",
        old_name="uq_devices_tenant_id_device_key",
        new_name="devices_device_key_key",
        old_columns=["tenant_id", "device_key"],
        new_columns=["device_key"],
    )
