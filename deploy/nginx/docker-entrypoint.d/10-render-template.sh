#!/bin/sh
set -eu

: "${BASELINER_DOMAIN:?BASELINER_DOMAIN is required}"  # API domain

# UI domain is optional for backward compatibility. If omitted, defaults to BASELINER_DOMAIN.
: "${BASELINER_UI_DOMAIN:=${BASELINER_DOMAIN}}"

TEMPLATE="/etc/nginx/templates/baseliner.conf.template"
OUT="/etc/nginx/conf.d/baseliner.conf"

INCLUDES_DIR="/etc/nginx/includes"

# ---------------------------
# Optional nginx edge features
# ---------------------------
# Both features are disabled by default and can be enabled independently:
#   - limit_req / limit_conn (per-IP)
#   - real_ip extraction (so $remote_addr reflects the true client IP behind a proxy/LB)

# Edge limiting (Issue #23 - nginx layer)
: "${NGINX_LIMITS_ENABLED:=false}"

# Token-bucket-style request limiting in nginx (per IP).
# Format is nginx's `rate=` syntax, e.g. "5r/s" or "60r/m".
: "${NGINX_LIMIT_REQ_REPORTS_RATE:=5r/s}"
: "${NGINX_LIMIT_REQ_REPORTS_BURST:=20}"
: "${NGINX_LIMIT_REQ_GENERAL_RATE:=10r/s}"
: "${NGINX_LIMIT_REQ_GENERAL_BURST:=40}"

# Concurrent connection limiting in nginx (per IP).
: "${NGINX_LIMIT_CONN_REPORTS_PER_IP:=20}"
: "${NGINX_LIMIT_CONN_GENERAL_PER_IP:=50}"

# Shared memory size for nginx limit zones.
: "${NGINX_LIMIT_REQ_ZONE_SIZE:=10m}"
: "${NGINX_LIMIT_CONN_ZONE_SIZE:=10m}"

# Real client IP extraction (optional)
: "${NGINX_REALIP_ENABLED:=false}"
# Common values: X-Forwarded-For, X-Real-IP, CF-Connecting-IP, True-Client-IP
: "${NGINX_REALIP_HEADER:=X-Forwarded-For}"
# on/off
: "${NGINX_REALIP_RECURSIVE:=on}"
# Comma- or space-separated CIDRs that are allowed to set the real IP.
# If empty, defaults to common private ranges (good for a local/host reverse proxy).
: "${NGINX_REALIP_TRUSTED_CIDRS:=}"

# Certs are stored under the "primary" domain used during initial issuance.
# We request the UI domain as primary and add the API domain as a SAN.
LE_CERT="/etc/letsencrypt/live/${BASELINER_UI_DOMAIN}/fullchain.pem"
LE_KEY="/etc/letsencrypt/live/${BASELINER_UI_DOMAIN}/privkey.pem"

BOOT_DIR="/etc/nginx/certs"
BOOT_CERT="${BOOT_DIR}/bootstrap.crt"
BOOT_KEY="${BOOT_DIR}/bootstrap.key"

mkdir -p "${BOOT_DIR}"
mkdir -p "${INCLUDES_DIR}"

rm_includes() {
  # Remove old generated includes so toggling env vars doesn't leave stale config behind.
  rm -f \
    "${INCLUDES_DIR}/baseliner-http-limits.inc" \
    "${INCLUDES_DIR}/baseliner-reports-limits.inc" \
    "${INCLUDES_DIR}/baseliner-general-limits.inc" \
    "${INCLUDES_DIR}/baseliner-http-realip.inc" \
    >/dev/null 2>&1 || true
}

write_limits() {
  case "${NGINX_LIMITS_ENABLED}" in
    1|true|TRUE|yes|YES|on|ON)
      # http{}-context includes: define zones and defaults.
      cat > "${INCLUDES_DIR}/baseliner-http-limits.inc" <<EOF_INNER
# Generated by 10-render-template.sh (NGINX_LIMITS_ENABLED=true)

# Return 429 when nginx blocks a request.
limit_req_status 429;
limit_conn_status 429;

# Keep logs useful but not too noisy.
limit_req_log_level warn;
limit_conn_log_level warn;

# Per-IP rate limit zones.
limit_req_zone \$binary_remote_addr zone=baseliner_reports_per_ip:${NGINX_LIMIT_REQ_ZONE_SIZE} rate=${NGINX_LIMIT_REQ_REPORTS_RATE};
limit_req_zone \$binary_remote_addr zone=baseliner_general_per_ip:${NGINX_LIMIT_REQ_ZONE_SIZE} rate=${NGINX_LIMIT_REQ_GENERAL_RATE};

# Per-IP connection limit zone.
limit_conn_zone \$binary_remote_addr zone=baseliner_conn_per_ip:${NGINX_LIMIT_CONN_ZONE_SIZE};
EOF_INNER

      # location{}-context include for POST /api/v1/device/reports
      cat > "${INCLUDES_DIR}/baseliner-reports-limits.inc" <<EOF_INNER
# Generated by 10-render-template.sh (NGINX_LIMITS_ENABLED=true)

limit_req zone=baseliner_reports_per_ip burst=${NGINX_LIMIT_REQ_REPORTS_BURST} nodelay;
limit_conn baseliner_conn_per_ip ${NGINX_LIMIT_CONN_REPORTS_PER_IP};
EOF_INNER

      # location{}-context include for general endpoints
      cat > "${INCLUDES_DIR}/baseliner-general-limits.inc" <<EOF_INNER
# Generated by 10-render-template.sh (NGINX_LIMITS_ENABLED=true)

limit_req zone=baseliner_general_per_ip burst=${NGINX_LIMIT_REQ_GENERAL_BURST} nodelay;
limit_conn baseliner_conn_per_ip ${NGINX_LIMIT_CONN_GENERAL_PER_IP};
EOF_INNER

      echo "[OK] Nginx edge limits enabled (limit_req + limit_conn)"
      ;;
    *)
      echo "[INFO] Nginx edge limits disabled (set NGINX_LIMITS_ENABLED=true to enable)"
      ;;
  esac
}

write_realip() {
  case "${NGINX_REALIP_ENABLED}" in
    1|true|TRUE|yes|YES|on|ON)
      # Build trusted CIDRs list.
      TRUSTED="${NGINX_REALIP_TRUSTED_CIDRS}"
      if [ -z "${TRUSTED}" ]; then
        # Safe-ish defaults for common "nginx-on-host" or docker bridge setups.
        TRUSTED="127.0.0.1/32 ::1/128 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16 fc00::/7"
      fi

      OUTFILE="${INCLUDES_DIR}/baseliner-http-realip.inc"
      {
        echo "# Generated by 10-render-template.sh (NGINX_REALIP_ENABLED=true)"
        echo
        echo "real_ip_header ${NGINX_REALIP_HEADER};"
        echo "real_ip_recursive ${NGINX_REALIP_RECURSIVE};"
        echo
        # Trust only the proxies/LBs you control. This controls who is allowed to set the "real IP".
        for cidr in $(echo "${TRUSTED}" | tr ',' ' '); do
          if [ -n "${cidr}" ]; then
            echo "set_real_ip_from ${cidr};"
          fi
        done
      } > "${OUTFILE}"

      echo "[OK] Nginx real_ip enabled (header=${NGINX_REALIP_HEADER}, recursive=${NGINX_REALIP_RECURSIVE})"
      ;;
    *)
      echo "[INFO] Nginx real_ip disabled (set NGINX_REALIP_ENABLED=true to enable)"
      ;;
  esac
}

rm_includes
write_limits
write_realip

if [ ! -f "${BOOT_CERT}" ] || [ ! -f "${BOOT_KEY}" ]; then
  echo "[INFO] Generating bootstrap self-signed cert for ${BASELINER_UI_DOMAIN}"
  openssl req -x509 -nodes -newkey rsa:2048 \
    -keyout "${BOOT_KEY}" \
    -out "${BOOT_CERT}" \
    -days 7 \
    -subj "/CN=${BASELINER_UI_DOMAIN}" >/dev/null 2>&1
fi

if [ -f "${LE_CERT}" ] && [ -f "${LE_KEY}" ]; then
  export SSL_CERT="${LE_CERT}"
  export SSL_KEY="${LE_KEY}"
  echo "[OK] Using Let's Encrypt certs for ${BASELINER_UI_DOMAIN} (SAN may include ${BASELINER_DOMAIN})"
else
  export SSL_CERT="${BOOT_CERT}"
  export SSL_KEY="${BOOT_KEY}"
  echo "[WARN] Let's Encrypt cert not found yet; using bootstrap self-signed cert for ${BASELINER_UI_DOMAIN}"
fi

if [ ! -f "$TEMPLATE" ]; then
  echo "[ERROR] Missing template: $TEMPLATE" >&2
  exit 1
fi

envsubst '${BASELINER_DOMAIN} ${BASELINER_UI_DOMAIN} ${SSL_CERT} ${SSL_KEY}' < "$TEMPLATE" > "$OUT"
echo "[OK] Rendered nginx site config for BASELINER_DOMAIN=$BASELINER_DOMAIN BASELINER_UI_DOMAIN=$BASELINER_UI_DOMAIN"
